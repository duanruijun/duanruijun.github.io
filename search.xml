<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker学习笔记]]></title>
    <url>%2F2019%2F09%2F27%2Fdocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[docker学习笔记镜像操作搜索镜像docker search 镜像名称 123456789[root@bogon ~]# docker search centosINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/centos The official build of CentOS. 5571 [OK] docker.io docker.io/ansible/centos7-ansible Ansible on Centos7 123 [OK]docker.io docker.io/jdeathe/centos-ssh OpenSSH / Supervisor / EPEL/IUS/SCL Repos ... 112 [OK]docker.io docker.io/consol/centos-xfce-vnc Centos container with &quot;headless&quot; VNC sessi... 99 [OK]docker.io docker.io/centos/mysql-57-centos7 MySQL 5.7 SQL database server 63 docker.io docker.io/imagine10255/centos6-lnmp-php56 centos6-lnmp-php56 57 [OK].... 获取镜像docker pull 镜像名称 12345678# 示例[root@bogon ~]# docker pull docker.io/centosUsing default tag: latestTrying to pull repository docker.io/library/centos ... latest: Pulling from docker.io/library/centosd8d02d457314: Pull complete Digest: sha256:307835c385f656ec2e2fec602cf093224173c51119bbebd602c53c3653a3d6ebStatus: Downloaded newer image for docker.io/centos:latest 查看镜像信息docker images 12345# 示例[root@bogon ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest adca3d04a9c3 9 minutes ago 202 MBdocker.io/centos latest 67fa590cfc1c 4 weeks ago 202 MB 删除镜像docker rmi 镜像名称 1234# 示例[root@bogon ~]# docker rmi centosUntagged: centos:latestUntagged: docker.io/centos@sha256:307835c385f656ec2e2fec602cf093224173c51119bbebd602c53c3653a3d6eb 创建镜像基于已有镜像的容器创建docker commit … 123-a, --author=&quot;&quot; 作者信息-m, --message=&quot;&quot; 提交信息-p, --pause==true 提交时暂停容器运行 123456789101112131415161718# 示例[root@bogon ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/centos latest 67fa590cfc1c 4 weeks ago 202 MB[root@bogon ~]# docker run -ti docker.io/centos /bin/bash[root@507ae2970ce5 /]# touch test[root@507ae2970ce5 /]# exit[root@bogon ~]# docker commit -m &quot;add a new file&quot; -a &quot;Duan.rj&quot; 507ae2970ce5 testsha256:adca3d04a9c3857e0debf1814ebf68c639bb013630910adcbcb2463b05044f12# 成功后会返回新创建的镜像ID，如上图# 查看新创建的镜像：[root@bogon ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest adca3d04a9c3 56 seconds ago 202 MBdocker.io/centos latest 67fa590cfc1c 4 weeks ago 202 MB 容器操作新建容器docker create -it … 123456# 示例[root@bogon ~]# docker create -it centos:latest3f1b6af49bb02c329b1cd9ad9414797978963a3909477e0b2dfce125860d571c[root@bogon ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 17 seconds ago Created flamboyant_easley 上述为新建一个容器，但是处于停止状态，可以使用docker start命令启动它。 123456# 示例[root@bogon ~]# docker start 3f1b6af49bb03f1b6af49bb0[root@bogon ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 3 minutes ago Up 4 seconds flamboyant_easley 新建并启动容器启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一种是将在终止状态的容器重新启动。所需命令为docker run，等价于先执行docker create命令，再执行docker start命令。 1234567# 示例[root@bogon ~]# docker run centos /bin/echo &quot;Hello world&quot;Hello world[root@bogon ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc2ded0c4a577 centos &quot;/bin/echo &apos;Hello ...&quot; 4 seconds ago Exited (0) 3 seconds ago silly_hoover3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 9 minutes ago Up 5 minutes flamboyant_easley 启动一个bash终端，允许用户进行交互：123456789101112# 示例[root@bogon ~]# docker run -t -i centos /bin/bash[root@a61f9ada2179 /]# pwd/[root@a61f9ada2179 /]# lsanaconda-post.log bin dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@a61f9ada2179 /]# ps PID TTY TIME CMD 1 ? 00:00:00 bash 15 ? 00:00:00 ps[root@a61f9ada2179 /]# exitexit 守护状态运行通过“-d”参数实现 1234567891011# 示例[root@bogon ~]# docker run -d centos /bin/sh -c &quot;while true;do echo hello world; sleep 1;done&quot;4ef71250e5e534176e7b3ff59f238b26b771612707a415786d0433ee3eea9859[root@bogon ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4ef71250e5e5 centos &quot;/bin/sh -c &apos;while...&quot; 6 seconds ago Up 5 seconds vibrant_wiles3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 14 minutes ago Up 10 minutes flamboyant_easley[root@bogon ~]# docker logs 4ef7hello worldhello world... 终止容器可以通过docker stop终止运行中的容器，命令格式为docker stop [-t|—time[=10]]。它会首先向容器发送SIGTERM信号，等待一段时间后（默认为10秒），再发送SIGKILL信号终止容器 12345678910# 示例[root@bogon ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4ef71250e5e5 centos &quot;/bin/sh -c &apos;while...&quot; 7 minutes ago Up 7 minutes vibrant_wiles3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 21 minutes ago Up 18 minutes flamboyant_easley[root@bogon ~]# docker stop 4ef71250e5e54ef71250e5e5[root@bogon ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 22 minutes ago Up 18 minutes flamboyant_easley 进入容器在使用-d进入后台后，如果需要进入容器进行操作，可以使用docker attach、docker exec、nsenter工具等。 docker attach1234567# 示例[root@bogon ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 32 minutes ago Up 28 minutes flamboyant_easley[root@bogon ~]# docker exec -ti 3f1b6af49bb0 /bin/bash[root@3f1b6af49bb0 /]# lsanaconda-post.log bin dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 删除容器docker rm删除一个处于停止状态的容器 123-f, --force=false 强行终止并删除一个运行中的容器。-l, --link=false 删除容器的连接，但保留容器。-v, --volumes=false 删除容器挂载的数据卷。 12345678910111213141516171819202122# 示例[root@bogon ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4482fc316c14 centos &quot;/bin/bash&quot; 6 minutes ago Exited (0) 4 minutes ago nifty_jennings4ef71250e5e5 centos &quot;/bin/sh -c &apos;while...&quot; 22 minutes ago Exited (137) 14 minutes ago vibrant_wilesa61f9ada2179 centos &quot;/bin/bash&quot; 25 minutes ago Exited (0) 25 minutes ago vibrant_brattainc2ded0c4a577 centos &quot;/bin/echo &apos;Hello ...&quot; 27 minutes ago Exited (0) 27 minutes ago silly_hoover3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 36 minutes ago Up 32 minutes flamboyant_easley1fa5a642a73d test &quot;/bin/bash&quot; 58 minutes ago Exited (0) 58 minutes ago brave_meitner507ae2970ce5 docker.io/centos &quot;/bin/bash&quot; About an hour ago Exited (0) About an hour ago xenodochial_wiles[root@bogon ~]# docker rm 4482fc316c144482fc316c14[root@bogon ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4ef71250e5e5 centos &quot;/bin/sh -c &apos;while...&quot; 23 minutes ago Exited (137) 14 minutes ago vibrant_wilesa61f9ada2179 centos &quot;/bin/bash&quot; 26 minutes ago Exited (0) 26 minutes ago vibrant_brattainc2ded0c4a577 centos &quot;/bin/echo &apos;Hello ...&quot; 28 minutes ago Exited (0) 28 minutes ago silly_hoover3f1b6af49bb0 centos:latest &quot;/bin/bash&quot; 37 minutes ago Up 33 minutes flamboyant_easley1fa5a642a73d test &quot;/bin/bash&quot; 58 minutes ago Exited (0) 58 minutes ago brave_meitner507ae2970ce5 docker.io/centos &quot;/bin/bash&quot; About an hour ago Exited (0) About an hour ago xenodochial_wiles 仓库registry镜像方式搭建本地私有仓库12# 示例docker run -d -p 5000:5000 registry 此时，这将下载并启动一个监听5000端口的registry容器，创建本地私有仓库服务。默认情况下，会将仓库创建在容器的/tmp/registry目录下，可以通过-v参数来将镜像文件存放在本地其他指定路径下： 12# 示例docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry 上传镜像 1234567# 查看镜像[root@bogon tmp]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/centos latest 67fa590cfc1c 5 weeks ago 202 MB# docker tag命令将要上传的镜像(docker.io/centos)标记为仓库地址(格式为：docker tag IMAGES[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]):[root@bogon tmp]# docker tag centos:latest 192.168.1.187:5000/test 192.168.1.187为仓库地址，接下来上传至仓库 1234# 示例[root@bogon tmp]# docker push 192.168.1.187:5000/testThe push refers to a repository [192.168.1.187:5000/test]Get https://192.168.1.187:5000/v1/_ping: http: server gave HTTP response to HTTPS client 这里出错，提示不是HTTPS协议，docker官方强烈推荐https协议，如果没有，可在docker配置文件中添加“insecure-registries”:[“192.168.1.187:5000”]指定： 123# 示例[root@bogon tmp]# cat /etc/docker/daemon.json &#123; &quot;insecure-registries&quot;:[&quot;192.168.1.187:5000&quot;] &#125; 重启docker并再次push操作 123456# 示例[root@bogon tmp]# systemctl restart docker[root@bogon tmp]# docker push 192.168.1.187:5000/testThe push refers to a repository [192.168.1.187:5000/test]877b494a9f30: Pushed latest: digest: sha256:a36b9e68613d07eec4ef553da84d0012a5ca5ae4a830cf825bb68b929475c869 size: 529 这样，就能push上去了，可在其他docker客户端配置中下载： 123456789101112# 示例[root@localhost ~]# docker pull 192.168.1.187:5000/testUsing default tag: latestTrying to pull repository 192.168.1.187:5000/test ... latest: Pulling from 192.168.1.187:5000/testd8d02d457314: Pull complete Digest: sha256:a36b9e68613d07eec4ef553da84d0012a5ca5ae4a830cf825bb68b929475c869Status: Downloaded newer image for 192.168.1.187:5000/test:latest[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE192.168.1.187:5000/test latest 67fa590cfc1c 5 weeks ago 202 MB 数据管理数据卷(volume)配置与本地host主机挂载，配置选项-v: 123456789101112131415161718192021# 示例[root@bogon ~]# docker run --name b2 -it -v /data centos[root@fa04a6cb63cf /]# #宿主机上查看b2容器的挂载情况[root@bogon ~]# docker inspect b2...&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;d40f1da12c8409119d25d847b9e17242d3ae2fe4bca7936764c04446b87cee44&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/d40f1da12c8409119d25d847b9e17242d3ae2fe4bca7936764c04446b87cee44/_data&quot;, ... &#125; ],&quot;Config&quot;: &#123; ... &quot;Volumes&quot;: &#123; &quot;/data&quot;: &#123;&#125; &#125;, ... 上述配置信息看到b2相关的volume存储位置在/data目录中，而挂载的宿主机的位置为：/var/lib/docker/volumes/d40f1da12c8409119d25d847b9e17242d3ae2fe4bca7936764c04446b87cee44/_data，我们可以在宿主机的这个目录中和b2的volume中分别测试验证挂载： 12345678# 示例# 宿主机执行[root@bogon ~]# cd /var/lib/docker/volumes/d40f1da12c8409119d25d847b9e17242d3ae2fe4bca7936764c04446b87cee44/_data/[root@bogon _data]# echo &quot;hello container&quot; &gt;&gt; test.html# b2容器执行[root@fa04a6cb63cf /]# cat data/test.html hello container 可以看到挂载成功，如果我们要指定宿主机的挂载位置只要在选项参数-v后添加相关位置即可，格式为：-v 宿主机位置:容器位置（例如：-v /data/volume/b2:/data），这种别称为绑定挂载卷 12# 示例[root@bogon ~]# docker run --name b2 -it -v /data/volume/b2:/data centos 把容器b2的/data目录挂载至宿主机的/data/volume/b2目录下，这样访问容器b2的/data目录中的数据实际是访问的宿主机的/data/volume/b2目录下的数据资源。 12345678910111213141516# 示例[root@bogon _data]# docker inspect b2[ ... &quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/data/volume/b2&quot;, &quot;Destination&quot;: &quot;/data&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125; ], ...] docker容器网络容器虚拟化网络大家知道Linux内核支持六中名称空间： UTS 管理主机名和域名 User 用户管理 Mount 挂载管理 IPC 管理进程间通信 Pid 进程id Net 网络管理 所谓网络名称空间是为了协议栈的隔离 未完待续。。。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins基本使用]]></title>
    <url>%2F2019%2F02%2F15%2Fjenkins%E8%87%AA%E5%AE%9A%E4%B9%89tag%2F</url>
    <content type="text"><![CDATA[创建证书步骤证书存放目录123cd /home/gitsource/mkdir &lt;item_name&gt;cd &lt;item_name&gt; 创建全局存储证书1git config --global credential.helper store 获取版本(账号|密码)1git clone &lt;Gitlab_url&gt; 获取tag列表1git ls-remote -h -t &lt;Gitlab_url&gt; refs/tags/* Jenkins配置添加动态选择变量12345678910111213141516171819202122232425262728# 创建变量参数Dynamic Choice ParameterName =&gt;select_tagChoices =&gt;proc1 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;git ls-remote -h -t http://git.epailive.com/epailive/phpweb.git refs/tags/v* &quot;].execute()proc2 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;awk &apos;&#123;print \$2&#125;&apos;&quot;].execute()proc3 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;sed s%^refs/heads%origin%&quot;].execute()proc4 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;sort -nr&quot;].execute()proc5 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;grep -v &#123;&#125;&quot;].execute()all = proc1 | proc2 | proc3 | proc4 |proc5String result = all.textresult.tokenize()=&gt; 更改后，获取的字符串确实不用sed替换proc1 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;git ls-remote -h -t http://git.epailive.com/epailive/phpweb.git refs/tags/v* &quot;].execute()proc2 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;awk &apos;&#123;print \$2&#125;&apos;&quot;].execute()proc3 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;sort -nr&quot;].execute()proc4 = [&apos;/bin/bash&apos;, &apos;-c&apos;, &quot;grep -v &#123;&#125;&quot;].execute()all = proc1 | proc2 | proc3 | proc4String result = all.textresult.tokenize() 修改gitlab拉取规则123456789101112131415# 资源管理Git# Repository URL&lt;gitlab url&gt;# Credentials账号密码# Branch Specifier (blank for &apos;any&apos;)$&#123;select_tag&#125;# Additional Behaviours## check out to a sub-directory$&#123;BUILD_TAG&#125; //内置变量]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins基本使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell文件对比]]></title>
    <url>%2F2017%2F10%2F10%2Fshell%E6%96%87%E4%BB%B6%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[#!/bin/bash #----判断给定的文件是否存在---- if [ -d $1 ] && [ -d $2 ];then echo -e "俩个文件夹都存在,开始对俩个文件夹进行比对." else if [ -d $1 ];then echo "不存在文件夹:$2" exit else echo "不存在文件夹:$1" exit fi fi #----判断俩个文件中改动过的文件有哪些---- #判断俩个文件的文件和文件夹的个数 echo -e "\e[1;32m######查询每个文件总共有多少个文件和文件夹######\e[0m" fnum1=`ls -Rl $1|grep -e "^-"|wc -l` fnum2=`ls -Rl $2|grep -e "^-"|wc -l` dnum1=`ls -Rl $1|grep -e "^d"|wc -l` dnum2=`ls -Rl $2|grep -e "^d"|wc -l` echo -e "$1:下总共有\e[1;31m$dnum1\e[0m个文件夹,\e[1;31m$fnum1\e[0m个文件." echo -e "$2:下总共有\e[1;31m$dnum2\e[0m个文件夹,\e[1;31m$fnum2\e[0m个文件." #判断$2中新增或者减少的文件夹和文件有哪些 echo -e "\e[1;32m######查看$2中新增或者减少的文件或文件夹########\e[0m" only1=`diff -rq $1 $2|grep "^Only"|awk '{print $3,$4}'|grep -v "WEB\-INF"` only2=`diff -rq $1 $2|grep "^Only"|awk '{print $3,$4}'|grep "WEB\-INF"` echo -e "$only1" echo -e "\e[1;31m$only2\e[0m" #判断$2中改变的文件有哪些 echo -e "\e[1;32m############查看$2中改变的文件有哪些############\e[0m" change1=`diff -rq $1 $2|grep "^File"|awk '{print $2,"------",$4}'|grep -v "WEB\-INF"` change2=`diff -rq $1 $2|grep "^File"|awk '{print $2,"------",$4}'|grep "WEB\-INF"` echo -e "$change1" echo -e "\e[1;31m$change2\e[0m" #查看版本号是否已经更改 echo -e "\e[1;32m######---------查看是否更改版本号---------######\e[0m" cd $1 if [ -f version.html ];then version1=`cat version.html` else echo -e "\e[1;31m$1没有版本号信息.\e[0m" exit fi cd $2 if [ -f version.html ];then version2=`cat version.html` else echo -e "\e[1;31m$2没有版本号信息.\e[0m" exit fi if [ $version1 == $version2 ];then echo -e "\e[1;31m版本号未改动,$1和$2的版本号为$version1\e[0m" else echo -e "\e[1;31;1m版本号已经改动过\e[0m,$1的版本号为\e[1;31;1m$version1\e[0m,$2的版本号为\e[1;31;1m$version2\e[0m." fi]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell文件对比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ping包检测]]></title>
    <url>%2F2017%2F10%2F10%2Fpython_ping%E5%8C%85%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[ping包检测 #!/usr/bin/env python #-*- coding: utf-8 -*- import re import subprocess def check_alive(ip,count=1,timeout=1): ''' ping网络测试,通过调用ping命令,发送一个icmp包，从结果中通过正则匹配是否有100%关键字，有则表示丢包，无则表示正常 ''' cmd = 'ping -c %d -w %d %s' % (count,timeout,ip) p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True ) result = p.stdout.read() regex = re.findall('100% packet loss',result) if len(regex) == 0: print "\033[31m%s UP\033[0m" % (ip) else: print "\033[32m%s DOWN\033[0m" % (ip) if __name__ == "__main__": with file('/root/ip.txt','r') as f: for line in f.readlines(): ip = line.strip() check_alive(ip)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>ping包检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则]]></title>
    <url>%2F2017%2F07%2F20%2Fpython_%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[正则表达式字符 \d： 数字 \w： 字母 \t： 制表符 . ： 除回车外所有字符 次数 *： 大于等于0 +： 大于等1 {m}： 次数 {m,n}： {3,5}从3到5 re.match和re.searchre.match: 给出的字符串起始位置去匹配 re.search: 整个字符串去匹配 例子 import re result1 = re.match(&apos;\d+&apos;, &apos;a123fdsa234f4532&apos;) result2 = re.search(&apos;\d+&apos;, &apos;a123fdsa234f4532&apos;) print(result1) print(result2) 结果 None &lt;_sre.SRE_Match object; span=(1, 4), match=&apos;123&apos;&gt; 上面可看到，如果没有返回None，否则返回一个对象，如果要取到值则为print(result2.group())。 re.findall一直找到所有相关匹配项（适合一次，100次需要编译一百次）。 例子 result3 = re.findall(&apos;\d+&apos;,&apos;a123fdsa234f4532&apos;) print(result3) 结果 [&apos;123&apos;, &apos;234&apos;, &apos;4532&apos;] re.compile返回一个对象需要用findall函数获取字符串来匹配（适合多次）。 例子 com = re.compile(&apos;\d+&apos;) print(com.findall(&apos;a123fdsa234f4532&apos;)) 结果 [&apos;123&apos;, &apos;234&apos;, &apos;4532&apos;] re.group和re.groups re.group： 获取所有 re.groups：（只获取组里面（括号里）的匹配值） 例子 result3 = re.search(&apos;(\d+)fdsa(\d+)&apos;, &apos;a123fdsa234f4532&apos;) print(result3.group()) print(result3.groups()) 结果 123fdsa234 (&apos;123&apos;, &apos;234&apos;) 查找IP 例子 ip = &apos;12.32.123.432.23432fdsa+fds;fdsa192.23.32.44_fdsa#@9ds&apos; print(re.findall(&apos;(?:\d{1,3}\.){3}\d{1,3}&apos;, ip)) 结果 [&apos;12.32.123.432&apos;, &apos;192.23.32.44&apos;]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书籍]]></title>
    <url>%2F2017%2F03%2F05%2F%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[书籍收藏 《自控力》]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>Devops书籍</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django笔记]]></title>
    <url>%2F2017%2F02%2F27%2Fdjango%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[概述官网很多相关文档，省略。。。 一些文档是整理的网上资源，可以参考Yuan先生 的技术博客。 环境 python： 3.6 pip： 9.0.1 django： 1.11.7 安装Django 根据自己环境安装pip pip install Django 新建django工程 创建Django工程（根据自己环境配置修改） c:\Python36\Scripts\django-admin.exe startproject mysite mysite：django工程名称 cd mysite目录下 python manage.py startapp blog blog：应用名称 启动 python manage.py runserver 8090 目录结构mysite目录 manage.py #入口文件 mysite __init__.py #初始化文件 settings.py #项目主配置文件 urls.py #路由分配配置文件 wsgi.py #Django web server(封装socket,解析APP) blog目录 __init__.py admin.py apps.py models.py #数据库相关配置(orm) tests.py #检测、测试 views.py #视图函数 settings.py文件配置定义templates位置修改TEMPLATES中的DIRS: 'DIRS': [os.path.join(BASE_DIR, 'templates')], 最后效果为 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 创建APP后要在 INSTALLED_APPS 添加相应名称比如，我这里创建的是blog应用 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog', ] 添加mysql数据库连接DATABASES 中修改 DATABASES = { 'default': { # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE': 'django.db.backends.mysql', 'NAME': 'DBNAME', 'USER': 'username', 'PASSWORD': 'password', 'HOST': 'db_host', 'PORT': 'port', } } 注释掉错误警告 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] 指定静态文件位置（如：js、css、jpg等） STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'statics') ) 开启配置之旅第一个页面 blog APP下views.py文件添加一个展示数据的函数 from django.shortcuts import render, HttpResponse # Create your views here. def cur_time(request): return HttpResponse('hello world!') request： 请求，参数可以自定义，但必须有 HttpResponse： 返回（当请求成功后要返回的信息） mysite下的urls.py添加相关路由信息 from blog import views #导入blog下的views模块 urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^cur_time', views.cur_time), ] 运行启动命令 python manage.py runserver 8090 浏览器打开 localhost:8090/cur_time 就能看到 hello world!信息了。 添加html文件之前在 settings.py 配置文件中指定了html文件的路径。所以，django会在 templates 目录下获取html文件，在mysite工程下新建一个 templates 目录，最后整个工程目录机构为： mysite +mysite +blog +templates 在templates目录下新键一个cur_time.html的html文件并进行编辑，最后代码为 cat views.py from django.shortcuts import render, HttpResponse # Create your views here. import datetime def cur_time(request): times = datetime.datetime.now() return render(request, 'cur_time.html', {'abc': times}) cat cur_time.html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;body&gt; 当前时间： &lt;/body&gt; &lt;/html&gt; 解释 render： 模版渲染,第一个是请求参数&lt;request&gt;,第二个参数是跳转的url名称，第三个是传递变量 abc cur_time.html中的｛｛｝｝是jinja2的模版语言，abc 则是render传过来的变量名，注意两边有空格 再次访问浏览器，应该就能看到当前时间了。 HttpResponse与render的区别 HttpResponse： 一个类，后面跟一个字符串，是实例化的一个对象，直接返回给客户端浏览器，django所有返回给客户端浏览器都是通过这个类实现的 render 渲染工作，首先指定一个html文件，解析完成后调用HttpResponse类返回给客户端浏览器，html文件中的变量、｛｝都不会显示在客户端浏览器上 数据库连接做一个userInfo信息表单，当用户填入相关信息提交后，数据存入数据库中，并展示信息功能 如前面settings.py中的配置文件指定的数据库userInfo信息有三个字段：username、sex、email,所以需要在blog中的models.py进行初始化数据库操作 from django.db import models # Create your models here. class UserInfo(models.Model): username = models.CharField(max_length=64) sex = models.CharField(max_length=64) email = models.CharField(max_length=64) 运行初始化数据命令 python manage.py makemigrations 如果报类似如下错误 File "C:\Python36\lib\site-packages\django\db\__init__.py", line 33, in __getattr__ return getattr(connections[DEFAULT_DB_ALIAS], item) File "C:\Python36\lib\site-packages\django\db\utils.py", line 211, in __getitem__ backend = load_backend(db['ENGINE']) File "C:\Python36\lib\site-packages\django\db\utils.py", line 115, in load_backend return import_module('%s.base' % backend_name) File "C:\Python36\lib\importlib\__init__.py", line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) File "C:\Python36\lib\site-packages\django\db\backends\mysql\base.py", line 30, in 'Did you install mysqlclient or MySQL-python?' % e django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: No module named 'MySQLdb'. Did you install mysqlclient or MySQL-python? 原因：python3不支持MySQLdb，需要在工程mysite下的init.py文件中添加如下内容 import pymysql pymysql.install_as_MySQLdb() 切记 settings.py里的INSTALLED_APPS添加应用名称，否则报错： File "C:\Python36\lib\site-packages\django\db\models\base.py", line 118, in __new__ "INSTALLED_APPS." % (module, name) RuntimeError: Model class blog.models.UserInfo doesn't declare an explicit app_label and isn't in an application in INSTALLED_APPS. django不会创建数据库，所以要提前手动创建。 mysite下的urls.py添加路由指向 from django.conf.urls import url from django.contrib import admin from blog import views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^cur_time', views.cur_time), url(r'^userInfo', views.userInfo), #添加userInfo路由指向 ] views.py更新后的内容为： from django.shortcuts import render, HttpResponse from blog import models #导入models模块，用于数据库操作 # Create your views here. import datetime def cur_time(request): times = datetime.datetime.now() # return HttpResponse('hello world!') return render(request, 'cur_time.html', {'abc': times}) def userInfo(req): if req.method == "POST": u = req.POST.get('username', None) s = req.POST.get('sex', None) e = req.POST.get('email', None) # user={'username':username,"sex": sex, "email": email} models.UserInfo.objects.create( #插入数据 username=u, sex=s, email=e ) user_list = models.UserInfo.objects.all() #从数据库中获取所有数据 return render(req, "index.html", {"user_list": user_list}) index.html文件内容 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;body&gt; &lt;form action="/userInfo/" method="post"&gt; &lt;p&gt;姓名&lt;input type="text" name="username"&gt;&lt;/p&gt; &lt;p&gt;性别&lt;input type="text" name="sex"&gt;&lt;/p&gt; &lt;p&gt;邮箱&lt;input type="text" name="email"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="submit"&gt;&lt;/p&gt; &lt;/form&gt; &lt;table border="1px"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 表单以 post 提交后跳转到 userInfo 页面。 Django URL(路由系统)URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表；你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。 urlpatterns = [ url(正则表达式, views视图函数，参数，别名), ] 参数： 一个正则表达式字符串 一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 可选的要传递给视图函数的默认参数（字典形式） 一个可选的name参数 示例 from django.conf.urls import url from django.contrib import admin from blog import views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^cur_time', views.cur_time), url(r'^userInfo', views.userInfo), url(r'^articles/2003/$', views.special_case_2003), #url(r'^articles/[0-9]{4}/$', views.year_archive), url(r'^articles/([0-9]{4})/$', views.year_archive), #no_named group url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail), ] URL匹配规则是由上到下，比如url(r’^articles/2003/$’, views.special_case_2003)和url(r’^articles/([0-9]{4})/$’, views.year_archive) 这两条，都是匹配四个数字。如果URL是articles/2003，虽然也属于^articles/([0-9]{4})，但是会优先匹配url(r’^articles/2003/$’, views.special_case_2003)。 正则表达式添加（）后，指定的views的视图函数也要增加一个自定义的形参，如上面的url(r’^articles/([0-9]{4})/$’, views.year_archive)，在views.year_archive中的year_archive视图函数定义时也要添加一个形参： def year_archive(req,year): return HttpResponse(year) 浏览器访问时就会返回year值 多个()，year_archive要设定多个形参 正则分组（Named groups）有时候URL传参需要指定值，这里就会用到Python正则表达式的?Ppattern， named groups ret=re.search('(?P\d{3})/(?P\w{3})','weeew34ttt123/ooo') print(ret.group()) print(ret.group('id')) print(ret.group('name')) from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/(?P[0-9]{4})/$', views.year_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/$', views.month_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/(?P[0-9]{2})/$', views.article_detail), ] 参数名称（name param） urlpatterns = [ url(r'^index',views.index,name='bieming'), ] def index(req): if req.method=='POST': username=req.POST.get('username') password=req.POST.get('password') if username=='alex' and password=='123': return HttpResponse("登陆成功") return render(req,'index.html') &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;body&gt; &lt;form action="｛% url 'bieming' %｝" method="post"&gt; 用户名:&lt;input type="text" name="username"&gt; 密码:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="submit"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 导入其他URLconfs #At any point, your urlpatterns can “include” other URLconf modules. This #essentially “roots” a set of URLs below other ones. #For example, here’s an excerpt of the URLconf for the Django website itself. #It includes a number of other URLconfs: from django.conf.urls import include, url urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')), ] Django Views(视图函数)浏览器 –(Rquest)–&gt; WebServer 浏览器 &lt;–(Response)– WebServer http请求中产生两个核心对象： - http请求： HttpRequest对象 - http响应： HttpResponse对象 HttpRequest对象的属性和方法： # path： 请求页面的全路径，不包括域名 # # method： 请求中使用的HTTP方法的字符串表示。全大写表示。例如 # # if req.method=="GET": # # do_something() # # elseif req.method=="POST": # # do_something_else() # # GET: 包含所有HTTP GET参数的类字典对象 # # POST： 包含所有HTTP POST参数的类字典对象 # # 服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过 # HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用 # if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method=="POST" # # # # COOKIES: 包含所有cookies的标准Python字典对象；keys和values都是字符串。 # # FILES： 包含所有上传文件的类字典对象；FILES中的每一个Key都是标签中 name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys： # # filename： 上传文件名，用字符串表示 # content_type: 上传文件的Content Type # content： 上传文件的原始内容 # # # user： 是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果访问用户当前 # 没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你 # 可以通过user的is_authenticated()方法来辨别用户是否登陆： # if req.user.is_authenticated();只有激活Django中的AuthenticationMiddleware # 时该属性才可用 # # session： 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。 #方法 get_full_path(), 比如：http://127.0.0.1:8000/index33/?name=123 ,req.get_full_path()得到的结果就是/index33/?name=123 req.path:/index33 注意一个常用方法：request.POST.getlist(‘’) HttpResponse对象： 对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。 HttpResponse类在django.http.HttpResponse 在HttpResponse对象上扩展的常用方法： 页面渲染： render()（推荐） render_to_response(), 页面跳转： redirect("路径") locals()： 可以直接将函数中所有的变量传给模板 url.py url(r"login", views.login), url(r"yuan_back", views.yuan_back), views.py def login(req): if req.method=="POST": if 1: # return redirect("/yuan_back/") name="yuanhao" return render(req,"my backend.html",locals()) return render(req,"login.html",locals()) def yuan_back(req): name="duanruijun" return render(req,"my backend.html",locals()) login.html &lt;form action="/login/" method="post"&gt; &lt;p&gt;姓名&lt;input type="text" name="username"&gt;&lt;/p&gt; &lt;p&gt;性别&lt;input type="text" name="sex"&gt;&lt;/p&gt; &lt;p&gt;邮箱&lt;input type="text" name="email"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="submit"&gt;&lt;/p&gt; &lt;/form&gt; my backend.html &lt;h1&gt;用户｛｛ name ｝｝你好&lt;/h1&gt; #总结: render和redirect的区别: # 1 if render的页面需要模板语言渲染,需要的将数据库的数据加载到html,那么所有的这一部分 # 除了写在yuan_back的视图函数中,必须还要写在login中,代码重复,没有解耦. # 2 the most important: url没有跳转到/yuan_back/,而是还在/login/,所以当刷新后 # 又得重新登录. 模版什么是模版语言简单说就是html+逻辑控制语句。 模版常用用例 – 万能的句号点（.）urls.py from django.conf.urls import url from django.contrib import admin from app01 import views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), views.py from django.shortcuts import render import datetime # Create your views here. def index(req): class profile(object): def __init__(self, name, age): self.name = name self.age = age s1 = [1,22,333] s2 = {'username': 'duanrj', 'email': '123@qq.com'} s3 = datetime.datetime.now() s4 = profile("Bob", "20") s5 = 'hello' s6 = 6 s7 = [] s8 = "跳转" return render(req, 'index.html', { 'value1': s1, 'value2': s2, 'value3': s3, 'value4': s4, 'value5': s5, 'value6': s6, 'value7': s7, 'value8': s8, }) index.html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;body&gt; ====打印列表第n个值==== ｛｛ value1.2 ｝｝ ====打印dict的username值==== ｛｛ value2.username ｝｝ 打印对象的属性 ｛｛ value3.year ｝｝ ====打印对象的属性2==== ｛｛ value4 ｝｝ ｛｛ value4.name ｝｝ ｛｛ value4.age ｝｝ ====模版语言中的遍历==== ｛% for i in obj %｝ ｛｛ forloop.counter ｝｝:｛｛ i ｝｝ //索引从1开始 ｛｛ forloop.counter0 ｝｝:｛｛ i ｝｝ //索引从0开始 ｛% endfor %｝ ====filter:小写转为大写==== ｛｛ value5 | upper ｝｝ ｛｛ value5 | lower ｝｝ ｛｛ value5 | capfirst ｝｝ ｛｛ value5 | first ｝｝ ====算数运算==== ｛｛ value6 | add:5 ｝｝ ====为空时提示信息==== ｛｛ value7 | default:'空的' ｝｝ ====当成普通字符串处理==== ｛｛ value8 ｝｝ 如果想把类似于html 标签的都渲染出来可以这样 ｛% autoescape off %} ｛｛ value8 ｝｝ ｛% endautoescape %} 也可以用safe ｛｛ obj|safe ｝｝ ====禁止render==== ｛% verbatim %｝ ｛｛ name ｝｝ ｛% endverbatim %｝ &lt;/body&gt; &lt;/html&gt; filter作用于简单操作，简化前后端开发重复性工作]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监控网络设备]]></title>
    <url>%2F2017%2F02%2F23%2Fzabbix_monito%2F</url>
    <content type="text"><![CDATA[一、zabbix-server端安装snmp工具1yum -y install net-snmp-utils snmp-libs snmp-devel snmp 二、检测与路由器的连通性测试之前工作 路由上要开启snmp功能 本地snmp服务器的snmp的密码和路由上的密码一致 1vim /etc/snmp/snmpd.conf 测试连通性 1snmpwalk -v 2c -c 19e#! 10.18.221.4 - 2c：协议版本 - 19e#!：密码与路由一致， - 10.18.221.4：路由IP 注意selinux、iptables 如果出现上面信息说明成功 三、zabbix-server添加路由监控主机 –&gt; 创建主机 由于添加了密钥认证，须在zabbix-server中添加密钥管理–&gt;一般–&gt;选择宏，进行设置 过几分钟就能出相关监控项了！]]></content>
      <categories>
        <category>zabbix</category>
      </categories>
      <tags>
        <tag>监控网络设备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible问题汇总，不断更新中...]]></title>
    <url>%2F2017%2F02%2F23%2Fansible%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一、通过ssh代理传输文件超时hosts配置文件 12[TestServer]172.16.0.129 ansible_ssh_port=12345 ansible_ssh_common_args=&apos;-o ProxyCommand=&quot;ssh -q -p33115 root@111.222.333.444 nc %h %p&quot;&apos; 应用synchronize模块时提示类似如下信息： 123456789[root@xyzl-test3 ansible]# ansible TestServer -i /opt/App/ansible/TestServerHosts -m synchronize -a &quot;src=/opt/JenkinsCache/TestServer/TestServer.tar.gz dest=/opt/JenkinsCache/TestServer/&quot; [WARNING]: Invalid characters were found in group names but not replaced, use -vvvv to see details172.16.0.129 | FAILED! =&gt; &#123; &quot;changed&quot;: false, &quot;cmd&quot;: &quot;/bin/rsync --delay-updates -F --compress --archive --rsh=/bin/ssh -S none -o Port=33115 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null --out-format=&lt;&lt;CHANGED&gt;&gt;%i %n%L /opt/JenkinsCache/TestServer/TestServer.tar.gz 172.16.0.129:/opt/JenkinsCache/TestServer/TestServer/&quot;, &quot;msg&quot;: &quot;ssh: connect to host 172.16.0.129 port 12345: Connection timed out\r\nrsync: connection unexpectedly closed (0 bytes received so far) [sender]\nrsync error: unexplained error (code 255) at io.c(226) [sender=3.1.2]\n&quot;, &quot;rc&quot;: 255&#125; 因改成copy模块： 1234567891011121314151617181920[root@xyzl-test3 ansible]# ansible TestServer -i /opt/JenkinsCache/TestServer/TestServerHosts -m copy -a &quot;src=/opt/JenkinsCache/TestServer/TestServer.tar.gz dest=/opt/JenkinsCache/TestServer/TestServer/&quot; [WARNING]: Invalid characters were found in group names but not replaced, use -vvvv to see details172.16.0.129 | CHANGED =&gt; &#123; &quot;ansible_facts&quot;: &#123; &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot; &#125;, &quot;changed&quot;: true, &quot;checksum&quot;: &quot;f91ea3c7d14223d73cd5ac667112388b13f8b8f4&quot;, &quot;dest&quot;: &quot;/opt/JenkinsCache/TestServer/TestServer.tar.gz&quot;, &quot;gid&quot;: 0, &quot;group&quot;: &quot;root&quot;, &quot;md5sum&quot;: &quot;76cf7a69de2786d77327ab59f803fe1c&quot;, &quot;mode&quot;: &quot;0644&quot;, &quot;owner&quot;: &quot;root&quot;, &quot;size&quot;: 40923749, &quot;src&quot;: &quot;/root/.ansible/tmp/ansible-tmp-1570589569.14-59930443509260/source&quot;, &quot;state&quot;: &quot;file&quot;, &quot;uid&quot;: 0&#125;]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>ansible问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字段和方法]]></title>
    <url>%2F2016%2F10%2F23%2F%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[首先，要知道Python类中两个概念：字段和方法“字段”和“方法”都有“动态”和“静态”之分，即： 字段 静态字段 动态字段 方法 静态方法 动态方法 以下事例标明了：“静态字段”，“动态字段”以及“动态方法”是什么样子的，因为显而易见，就不用语言进行过多描述： #coding:utf-8 class Car: # 下面是静态字段 memo = u'车辆具有出厂合格证' def __init__(self, brand, model, speed, price, engine): # 下面是动态字段 self.Brand = brand self.Model = model self.Speed = speed self.Price = price self.__EngineType = engine # 下面是动态方法 def Turnleft(self): print self.Brand + u'开始向右转向。' 上述事例中，并没有展现“静态方法”，那么“静态方法”长什么样子？如何生成？其实“静态方法”只需要执行两步操作，就可以转换成“静态方法” 在方法前加上 @staticmethod 把“动态方法”括号中的“self”去掉 如： @staticmethod def Forward(): print u'开始向前进' 那么关于这四种类型，有什么特点？以下进行总结： 四种类型，均可以被“对象”进行调用，但不建议使用“对象”调用“静态方法”和“静态字段”，而建议使用“类”对其进行调用 “动态方法”和“动态字段”只能由“对象”进行调用，而无法使用“类”进行调用]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字段和方法说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux非root用户文件描述符限制]]></title>
    <url>%2F2015%2F02%2F27%2Flinux%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[描述在一次生产环境下切换非root用户，导致如下错误等待： 123456[root@xy_Tomcat_1 exam-service]# su - java-bash: fork: retry: Resource temporarily unavailable-bash: fork: retry: Resource temporarily unavailable-bash: fork: retry: Resource temporarily unavailable-bash: fork: retry: Resource temporarily unavailable-bash: fork: retry: Resource temporarily unavailable 通常上述问题发现是由于非root用户默认打开文件描述符为1024： 12345678cat /etc/security/limits.d/90-nproc.conf# Default limit for number of user&apos;s processes to prevent# accidental fork bombs.# See rhbz #432903 for reasoning.* soft nproc 1024root soft nproc unlimited 解决只要把非root用户值改为合适本身环境即可]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>非root用户最大连接数配置</tag>
      </tags>
  </entry>
</search>
