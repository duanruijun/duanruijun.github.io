<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[zabbix 监控cpu load]]></title>
    <url>%2F2018%2F03%2F12%2Fzabbix_%E7%9B%91%E6%8E%A7CPUload%2F</url>
    <content type="text"><![CDATA[场景 zabbix的cpu load要与系统（linux）上的对应（top）； 服务器的CPU核数不一致； 监控CPU核数总数/2触发报警； 思路 要动态获取zabbix-agent的core； 两个监控项目对比的差异（cpu_load&gt;cpu_num/2）并触发相关报警。 解决办法方法一 在各agent端配置自定义key，并在zabbix-server上设置相关触发器； 方法二 zabbix-server从触发器入手，直接动态获取； 方法一固然可行，但是在服务器数量庞大的基础下，虽然通过ansible等之类的工具把自定义key推送过去后再配置触发器，这样是不是有点“笨拙”？能不能从zabbix-server现有的key中寻找另一条路呢？答案当然是可以的！ 关键的两个key system.cpu.load[all,avg1] #1分钟的所有核数负载值 system.cpu.num 系统总核数 自定义触发器可参考触发器表达式,通过对自定义触发器的了解，就可以进行配置相关操作！ 展示效果{Template OS Linux-18:system.cpu.load[all,avg1].min(5m)}&gt;{Template OS Linux-18:system.cpu.num.last()}/2 最近5分钟的负载大于一半的核数就触发报警]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins maven项目实战1]]></title>
    <url>%2F2018%2F03%2F07%2Fjenkins_maven%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%981%2F</url>
    <content type="text"><![CDATA[环境 gitlab: http://192.168.62.206 jenkins: http://192.168.62.210:8080 depserver: 192.168.63.116 实例说明 gitlab工程地址：git@192.168.62.206:Mall/eureka.git jenkins构建完成后本地存放位置：/target depserver工程目录：/home/jiagouzu/tingyun/target/ 流程 jenkins通过gitlab pull工程代码 jenkins通过本地maven工具构建、打包工程代码 jenkins把完成的.jar推送到服务器相应目录下 注意事项 jenkins pull代码时，gitlab要确保有jenkins的Deploy key key信息 gitlab的项目“Mall/eureka”启用deploy key(settings–&gt; Repository–&gt;Deploy Keys)： jenkins配置说明jenkins配置depServer节点 添加depserver服务器节点（系统管理–&gt;系统设置–&gt;SSH Servers） 新建一个Server,完成后选择高级配置相关信息： 其他保持默认，最后选择Test Configuration可测试下 配置拉取gitlab地址私钥信息这里就不多讲了，具体步骤可见jenkins基本使用 创建项目 新建一个项目，类型为自由风格的（maven类型有很多限制），这里我的名称为“商城” 配置“商城”，在General标签里配置相关信息，注意点开“高级”选择“使用自定义的工作空间” 源码管理 构建触发器 手动还是自动构建，这里也可以看之前的文章jenkins基本使用 构建环境 构建（mvn命令执行构建） 这里注意mvn命令的位置，jenkins默认安装选择在 /home/apache-maven-3.5.2/bin/mvn 可通过（系统管理–&gt;全局工具配置）进行相应的更改，但要给予jenkins执行的权限，这里我把命令ln到/usr/local/bin目录下，chmod +x mvn 如果没有设置会报类似错误： [/target] $ /bin/sh -xe /tmp/jenkins6497126245319590786.sh + mvn clean package /tmp/jenkins6497126245319590786.sh: line 2: mvn: command not found Build step 'Execute shell' marked build as failure SSH: Current build result is [FAILURE], not going to run. 构建后操作（完成构建后的部署工作） 选择“Send build artifacts over SSH”,注意要安装 over ssh插件 注意： 这里的Remote directory指的就是前面配置depserver的工程目录地址“/home/jiagouzu/tingyun” 点击完成后就可以测试了，默认maven构建的配置文件直接找的官方地址，在构建日志当中会出现如下信息 https://repo.maven.apache.org/maven2/org/hibernate/hibernate-validator/5.3.6.Final/hibernate-validator-5.3.6.Final.jar (727 kB at 2.4 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/org/springframework/boot/spring-boot-starter-actuator/1.5.9.RELEASE/spring-boot-starter-actuator-1.5.9.RELEASE.jar 这里需要注意： 第一次构建时，maven需要下载部署工程所需要的jar包； 改善办法之一是同开发要一份maven构建工具的settings.xml 配置文件替换你的maven工具里的settings.xml（一般开发会有自己的内部仓库），在这里是我的jenkins服务器中的“/home/apache-maven-3.5.2/conf/settings.xml”，注意修改里面的“/MavenRepository”这是指你存放maven工具所需jar包的目录，别忘了给jenkins能执行的权限。 最后测试输出类似信息证明配置成功： [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 4.246 s [INFO] Finished at: 2018-03-07T14:54:53+08:00 [INFO] Final Memory: 36M/203M [INFO] ------------------------------------------------------------------------ SSH: Failed to get hostname [192v168v62v210: 192v168v62v210: 未知的名称或服务] SSH: Connecting with configuration [192.168.63.116] ... SSH: EXEC: STDOUT/STDERR from command [/bin/bash /home/mall_start.sh start] ... SSH: EXEC: completed after 200 ms SSH: Disconnecting configuration [192.168.63.116] ... SSH: Transferred 1 file(s) Finished: SUCCESS]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[devops书籍]]></title>
    <url>%2F2018%2F03%2F05%2Fdevops%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[书籍收藏]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>devops书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书籍]]></title>
    <url>%2F2018%2F03%2F05%2Fbooks%2F</url>
    <content type="text"><![CDATA[《自控力》]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django笔记]]></title>
    <url>%2F2018%2F02%2F27%2Fdjango%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[概述官网很多相关文档，省略。。。 一些文档是整理的网上资源，可以参考Yuan先生 的技术博客。 环境 python： 3.6 pip： 9.0.1 django： 1.11.7 安装Django 根据自己环境安装pip pip install Django 新建django工程 创建Django工程（根据自己环境配置修改） c:\Python36\Scripts\django-admin.exe startproject mysite mysite：django工程名称 cd mysite目录下 python manage.py startapp blog blog：应用名称 启动 python manage.py runserver 8090 目录结构mysite目录 manage.py #入口文件 mysite __init__.py #初始化文件 settings.py #项目主配置文件 urls.py #路由分配配置文件 wsgi.py #Django web server(封装socket,解析APP) blog目录 __init__.py admin.py apps.py models.py #数据库相关配置(orm) tests.py #检测、测试 views.py #视图函数 settings.py文件配置定义templates位置修改TEMPLATES中的DIRS: 'DIRS': [os.path.join(BASE_DIR, 'templates')], 最后效果为 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 创建APP后要在 INSTALLED_APPS 添加相应名称比如，我这里创建的是blog应用 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog', ] 添加mysql数据库连接DATABASES 中修改 DATABASES = { 'default': { # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE': 'django.db.backends.mysql', 'NAME': 'DBNAME', 'USER': 'username', 'PASSWORD': 'password', 'HOST': 'db_host', 'PORT': 'port', } } 注释掉错误警告 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] 指定静态文件位置（如：js、css、jpg等） STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'statics') ) 开启配置之旅第一个页面 blog APP下views.py文件添加一个展示数据的函数 from django.shortcuts import render, HttpResponse # Create your views here. def cur_time(request): return HttpResponse('hello world!') request： 请求，参数可以自定义，但必须有 HttpResponse： 返回（当请求成功后要返回的信息） mysite下的urls.py添加相关路由信息 from blog import views #导入blog下的views模块 urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^cur_time', views.cur_time), ] 运行启动命令 python manage.py runserver 8090 浏览器打开 localhost:8090/cur_time 就能看到 hello world!信息了。 添加html文件之前在 settings.py 配置文件中指定了html文件的路径。所以，django会在 templates 目录下获取html文件，在mysite工程下新建一个 templates 目录，最后整个工程目录机构为： mysite +mysite +blog +templates 在templates目录下新键一个cur_time.html的html文件并进行编辑，最后代码为 cat views.py from django.shortcuts import render, HttpResponse # Create your views here. import datetime def cur_time(request): times = datetime.datetime.now() return render(request, 'cur_time.html', {'abc': times}) cat cur_time.html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;body&gt; 当前时间： &lt;/body&gt; &lt;/html&gt; 解释 render： 模版渲染,第一个是请求参数&lt;request&gt;,第二个参数是跳转的url名称，第三个是传递变量 abc cur_time.html中的｛｛｝｝是jinja2的模版语言，abc 则是render传过来的变量名，注意两边有空格 再次访问浏览器，应该就能看到当前时间了。 HttpResponse与render的区别 HttpResponse： 一个类，后面跟一个字符串，是实例化的一个对象，直接返回给客户端浏览器，django所有返回给客户端浏览器都是通过这个类实现的 render 渲染工作，首先指定一个html文件，解析完成后调用HttpResponse类返回给客户端浏览器，html文件中的变量、｛｝都不会显示在客户端浏览器上 数据库连接做一个userInfo信息表单，当用户填入相关信息提交后，数据存入数据库中，并展示信息功能 如前面settings.py中的配置文件指定的数据库userInfo信息有三个字段：username、sex、email,所以需要在blog中的models.py进行初始化数据库操作 from django.db import models # Create your models here. class UserInfo(models.Model): username = models.CharField(max_length=64) sex = models.CharField(max_length=64) email = models.CharField(max_length=64) 运行初始化数据命令 python manage.py makemigrations 如果报类似如下错误 File "C:\Python36\lib\site-packages\django\db\__init__.py", line 33, in __getattr__ return getattr(connections[DEFAULT_DB_ALIAS], item) File "C:\Python36\lib\site-packages\django\db\utils.py", line 211, in __getitem__ backend = load_backend(db['ENGINE']) File "C:\Python36\lib\site-packages\django\db\utils.py", line 115, in load_backend return import_module('%s.base' % backend_name) File "C:\Python36\lib\importlib\__init__.py", line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) File "C:\Python36\lib\site-packages\django\db\backends\mysql\base.py", line 30, in 'Did you install mysqlclient or MySQL-python?' % e django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: No module named 'MySQLdb'. Did you install mysqlclient or MySQL-python? 原因：python3不支持MySQLdb，需要在工程mysite下的init.py文件中添加如下内容 import pymysql pymysql.install_as_MySQLdb() 切记 settings.py里的INSTALLED_APPS添加应用名称，否则报错： File "C:\Python36\lib\site-packages\django\db\models\base.py", line 118, in __new__ "INSTALLED_APPS." % (module, name) RuntimeError: Model class blog.models.UserInfo doesn't declare an explicit app_label and isn't in an application in INSTALLED_APPS. django不会创建数据库，所以要提前手动创建。 mysite下的urls.py添加路由指向 from django.conf.urls import url from django.contrib import admin from blog import views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^cur_time', views.cur_time), url(r'^userInfo', views.userInfo), #添加userInfo路由指向 ] views.py更新后的内容为： from django.shortcuts import render, HttpResponse from blog import models #导入models模块，用于数据库操作 # Create your views here. import datetime def cur_time(request): times = datetime.datetime.now() # return HttpResponse('hello world!') return render(request, 'cur_time.html', {'abc': times}) def userInfo(req): if req.method == "POST": u = req.POST.get('username', None) s = req.POST.get('sex', None) e = req.POST.get('email', None) # user={'username':username,"sex": sex, "email": email} models.UserInfo.objects.create( #插入数据 username=u, sex=s, email=e ) user_list = models.UserInfo.objects.all() #从数据库中获取所有数据 return render(req, "index.html", {"user_list": user_list}) index.html文件内容 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;body&gt; &lt;form action="/userInfo/" method="post"&gt; &lt;p&gt;姓名&lt;input type="text" name="username"&gt;&lt;/p&gt; &lt;p&gt;性别&lt;input type="text" name="sex"&gt;&lt;/p&gt; &lt;p&gt;邮箱&lt;input type="text" name="email"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="submit"&gt;&lt;/p&gt; &lt;/form&gt; &lt;table border="1px"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 表单以 post 提交后跳转到 userInfo 页面。 Django URL(路由系统)URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表；你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。 urlpatterns = [ url(正则表达式, views视图函数，参数，别名), ] 参数： 一个正则表达式字符串 一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 可选的要传递给视图函数的默认参数（字典形式） 一个可选的name参数 示例 from django.conf.urls import url from django.contrib import admin from blog import views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^cur_time', views.cur_time), url(r'^userInfo', views.userInfo), url(r'^articles/2003/$', views.special_case_2003), #url(r'^articles/[0-9]{4}/$', views.year_archive), url(r'^articles/([0-9]{4})/$', views.year_archive), #no_named group url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail), ] URL匹配规则是由上到下，比如url(r’^articles/2003/$’, views.special_case_2003)和url(r’^articles/([0-9]{4})/$’, views.year_archive) 这两条，都是匹配四个数字。如果URL是articles/2003，虽然也属于^articles/([0-9]{4})，但是会优先匹配url(r’^articles/2003/$’, views.special_case_2003)。 正则表达式添加（）后，指定的views的视图函数也要增加一个自定义的形参，如上面的url(r’^articles/([0-9]{4})/$’, views.year_archive)，在views.year_archive中的year_archive视图函数定义时也要添加一个形参： def year_archive(req,year): return HttpResponse(year) 浏览器访问时就会返回year值 多个()，year_archive要设定多个形参 正则分组（Named groups）有时候URL传参需要指定值，这里就会用到Python正则表达式的?Ppattern， named groups ret=re.search('(?P\d{3})/(?P\w{3})','weeew34ttt123/ooo') print(ret.group()) print(ret.group('id')) print(ret.group('name')) from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/(?P[0-9]{4})/$', views.year_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/$', views.month_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/(?P[0-9]{2})/$', views.article_detail), ] 参数名称（name param） urlpatterns = [ url(r'^index',views.index,name='bieming'), ] def index(req): if req.method=='POST': username=req.POST.get('username') password=req.POST.get('password') if username=='alex' and password=='123': return HttpResponse("登陆成功") return render(req,'index.html') &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;body&gt; &lt;form action="｛% url 'bieming' %｝" method="post"&gt; 用户名:&lt;input type="text" name="username"&gt; 密码:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="submit"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 导入其他URLconfs #At any point, your urlpatterns can “include” other URLconf modules. This #essentially “roots” a set of URLs below other ones. #For example, here’s an excerpt of the URLconf for the Django website itself. #It includes a number of other URLconfs: from django.conf.urls import include, url urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')), ] Django Views(视图函数)浏览器 –(Rquest)–&gt; WebServer 浏览器 &lt;–(Response)– WebServer http请求中产生两个核心对象： - http请求： HttpRequest对象 - http响应： HttpResponse对象 HttpRequest对象的属性和方法： # path： 请求页面的全路径，不包括域名 # # method： 请求中使用的HTTP方法的字符串表示。全大写表示。例如 # # if req.method=="GET": # # do_something() # # elseif req.method=="POST": # # do_something_else() # # GET: 包含所有HTTP GET参数的类字典对象 # # POST： 包含所有HTTP POST参数的类字典对象 # # 服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过 # HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用 # if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method=="POST" # # # # COOKIES: 包含所有cookies的标准Python字典对象；keys和values都是字符串。 # # FILES： 包含所有上传文件的类字典对象；FILES中的每一个Key都是标签中 name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys： # # filename： 上传文件名，用字符串表示 # content_type: 上传文件的Content Type # content： 上传文件的原始内容 # # # user： 是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果访问用户当前 # 没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你 # 可以通过user的is_authenticated()方法来辨别用户是否登陆： # if req.user.is_authenticated();只有激活Django中的AuthenticationMiddleware # 时该属性才可用 # # session： 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。 #方法 get_full_path(), 比如：http://127.0.0.1:8000/index33/?name=123 ,req.get_full_path()得到的结果就是/index33/?name=123 req.path:/index33 注意一个常用方法：request.POST.getlist(‘’) HttpResponse对象： 对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。 HttpResponse类在django.http.HttpResponse 在HttpResponse对象上扩展的常用方法： 页面渲染： render()（推荐） render_to_response(), 页面跳转： redirect("路径") locals()： 可以直接将函数中所有的变量传给模板 url.py url(r"login", views.login), url(r"yuan_back", views.yuan_back), views.py def login(req): if req.method=="POST": if 1: # return redirect("/yuan_back/") name="yuanhao" return render(req,"my backend.html",locals()) return render(req,"login.html",locals()) def yuan_back(req): name="duanruijun" return render(req,"my backend.html",locals()) login.html &lt;form action="/login/" method="post"&gt; &lt;p&gt;姓名&lt;input type="text" name="username"&gt;&lt;/p&gt; &lt;p&gt;性别&lt;input type="text" name="sex"&gt;&lt;/p&gt; &lt;p&gt;邮箱&lt;input type="text" name="email"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="submit"&gt;&lt;/p&gt; &lt;/form&gt; my backend.html &lt;h1&gt;用户｛｛ name ｝｝你好&lt;/h1&gt; #总结: render和redirect的区别: # 1 if render的页面需要模板语言渲染,需要的将数据库的数据加载到html,那么所有的这一部分 # 除了写在yuan_back的视图函数中,必须还要写在login中,代码重复,没有解耦. # 2 the most important: url没有跳转到/yuan_back/,而是还在/login/,所以当刷新后 # 又得重新登录. 模版什么是模版语言简单说就是html+逻辑控制语句。 模版常用用例 – 万能的句号点（.）urls.py from django.conf.urls import url from django.contrib import admin from app01 import views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), views.py from django.shortcuts import render import datetime # Create your views here. def index(req): class profile(object): def __init__(self, name, age): self.name = name self.age = age s1 = [1,22,333] s2 = {'username': 'duanrj', 'email': '123@qq.com'} s3 = datetime.datetime.now() s4 = profile("Bob", "20") s5 = 'hello' s6 = 6 s7 = [] s8 = "跳转" return render(req, 'index.html', { 'value1': s1, 'value2': s2, 'value3': s3, 'value4': s4, 'value5': s5, 'value6': s6, 'value7': s7, 'value8': s8, }) index.html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;body&gt; ====打印列表第n个值==== ｛｛ value1.2 ｝｝ ====打印dict的username值==== ｛｛ value2.username ｝｝ 打印对象的属性 ｛｛ value3.year ｝｝ ====打印对象的属性2==== ｛｛ value4 ｝｝ ｛｛ value4.name ｝｝ ｛｛ value4.age ｝｝ ====模版语言中的遍历==== ｛% for i in obj %｝ ｛｛ forloop.counter ｝｝:｛｛ i ｝｝ //索引从1开始 ｛｛ forloop.counter0 ｝｝:｛｛ i ｝｝ //索引从0开始 ｛% endfor %｝ ====filter:小写转为大写==== ｛｛ value5 | upper ｝｝ ｛｛ value5 | lower ｝｝ ｛｛ value5 | capfirst ｝｝ ｛｛ value5 | first ｝｝ ====算数运算==== ｛｛ value6 | add:5 ｝｝ ====为空时提示信息==== ｛｛ value7 | default:'空的' ｝｝ ====当成普通字符串处理==== ｛｛ value8 ｝｝ 如果想把类似于html 标签的都渲染出来可以这样 ｛% autoescape off %} ｛｛ value8 ｝｝ ｛% endautoescape %} 也可以用safe ｛｛ obj|safe ｝｝ ====禁止render==== ｛% verbatim %｝ ｛｛ name ｝｝ ｛% endverbatim %｝ &lt;/body&gt; &lt;/html&gt; filter作用于简单操作，简化前后端开发重复性工作]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>django笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix低级发现]]></title>
    <url>%2F2018%2F02%2F24%2Fzabbix_%E4%BD%8E%E7%BA%A7%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、(low level discover)概述 什么是lld ？即低水平自动发现，使用它可以自动创建项目、触发器及被监控主机上的实体图。如zabbix 可以自动监控主机上的文件系统和网络拉口，而不需要为每个监控项创建items 。此处，其也可以实现被监控项目的自动删除 。上面的话不是我的总结，是我从官方文档上翻译过来的话。 二、创建模版 由于创建模板不是本篇的重点，就不提创建模板的过程了 。这里重点提下如何在模板中创建自动发现规则。 1. 创建自动发现规则 步骤为：配置 –&gt; 模版 –&gt; 选中之前创建好的模版(这里我用 app discover) –&gt; 自动发现规则 –&gt; 创建发现规则 2. 选择监控项原型并创建监控项 名称：｛#DISCOVER} 自定义的宏变量（后续脚本会提到)； 类型：根据自身主动/被动模式选择； 键值：后续监控的自定义Key会提到。 3. 触发器类型 可根据自身情况做定义 三、客户端配置脚本（在配置发现的主机上配置，比如zabbix-server的agentd） 配置发现规则 这里发现规则是找的/app目录下的所有目录名（公司的所有项目都创建在/app目录下） cat check_app.py #!/usr/bin/env python #-*- coding:utf-8 -*- #@author: sundsinerj #@date: 2017/9/28 import os import json import getopt import sys #list app name app_list = os.listdir(os.path.expanduser("/app")) if 'lost+found' in app_list: del app_list[app_list.index('lost+found')] elif 'zabbix' in app_list: del app_list[app_list.index('lost+found')] elif 'tomcat-6.0.48_wp' in app_list: del app_list[app_list.index('lost+found')] opts, arge = getopt.getopt(sys.argv[1:],[]) #print appname for json pool_list = [] for appname in app_list: #def json data pool_list += [｛'｛#DISCOVER｝': appname｝] print json.dumps({'data': pool_list},sort_keys=True,indent=4,separators=(',',':')) 配置监控项规则 cat check_app.sh #! /bin/bash help() { echo "USAGE:`basename $0` [-n] the name of app" exit -1 } while getopts ":n" opt do case $opt in n) appname=$OPTARG ;; h) help ;; *) unkown=$OPTARG echo "error,plase check for help,USAGE:./`basename $0` -h" exit $STAT_UNKNOWN ;; esac done apppid=`ps aux | grep "$appname" | grep -v grep | wc -c` if [ $apppid -eq 0 ] then echo 0 exit 0 else echo 1 exit 1 fi 发现规则必需是json格式的 *｛#DISCOVER｝ 就是zabbix创建的模版的宏变量 check_app.sh脚本就是定义的监控项 四、自定义key cat userparameter_app.conf UserParameter=app.status[*],/bin/bash /etc/zabbix/zabbix_agentd.d/libexec/check_app.sh -n $1 UserParameter=app.discover,python /etc/zabbix/zabbix_agentd.d/libexec/check_app.py 五、验证在被发现的主机上关联app discover 模版就可以了。过会，就能看到相关的低级发现项目。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix_proxy]]></title>
    <url>%2F2018%2F02%2F23%2Fzabbix_proxy%2F</url>
    <content type="text"><![CDATA[概述zabbix proxy可以代替zabbix server收集性能和可用性数据，然后把数据汇报给zabbix server，并且在一定程度上分担zabbix server的压力，具体可见官方文档。 样例 服务列表 | 名称 | IP | |——–|:——–:| | zabbix server | 10.18.12.98 | | zabbix proxy | 10.18.12.93 | | zabbix agent | 10.18.12.63 | zabbix agent配置文件 cat /etc/zabbix_agentd.conf LogFile=/log/zabbix/zabbix_agentd.log PidFile=/log/zabbix/zabbix_agentd.pid StartAgents=0 ServerActive=10.18.12.93 RefreshActiveChecks=120 BufferSend=5 BufferSize=100 Hostname=10.18.12.63 DebugLevel=3 Timeout=20 MaxLinesPerSecond=100 AllowRoot=1 Include=/etc/zabbix/zabbix_agentd.d/*.conf ServerActive: 代理节点IP zabbix proxy配置文件 cat /etc/zabbix/zabbix_proxy.conf Server=10.18.12.98 Hostname=Zabbix_proxy_18 LogFile=/log/zabbix/zabbix_proxy.log DebugLevel=3 DBName=zabbix DBUser=zabbix DBPassword=zabbix ProxyLocalBuffer=0 ProxyOfflineBuffer=1 ConfigFrequency=30 DataSenderFrequency=30 StartPollers=100 StartPollersUnreachable=1 StartTrappers=200 StartPingers=1 CacheSize=64M TrapperTimeout=30 Timeout=10 LogSlowQueries=3000 Server: zabbix server IP Hostname: 代理节点IP DB* 由于代理节点要暂存agent传来的数据，所以，要先把数据缓存在本地(proxy)数据库中，再定时和zabbix server进行数据交互； zabbix server配置文件 无 web端配置 1) 添加代理节点 管理&gt;&gt;agent代理程序&gt;&gt;创建代理 样例中配置的名称是zabbix_proxy_18 2) 在agent主机的最下方选择zabbix_proxy_18 完成配置后生效 过会在zabbix proxy服务端查看相关日志，如果里面有zabbix agent的数据展示信息，证明zabbix proxy配置成功。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix问题汇总]]></title>
    <url>%2F2018%2F02%2F23%2Fzabbix%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一、agent连接正常，server端报agent.ping问题由来zabbix-server迁移到server2上，zabbix架构为zabbix-agent –&gt; zabbix_proxy –&gt; zabbix_server； zabbix-server迁移进行时，zabbix_proxy没做停止，zabbix-server迁移完成后，zabbix_proxy指定的还是server1。这时，zabbix-server2收不到所有zabbix_proxy的数据，因此产生大量报警，当zabbix_proxy的Server字段改为zabbix-server2后，数据同步了，但是极有可能造成zabbix-server下的部分agent节点的触发器agent.ping还没有得到响应，而迁移后的数据也能在新的server上展示。 解决办法把有问题的agent节点关闭，等待server端重新出发一次agent.ping（相当于更新下之前的状态）,当server收到新的报警后，再把问题agent启动。这样就能覆盖掉问题agent.ping。 二、报警风暴由来当大量zabbix_agent单位时间内连接超时，故障修复后，会产生大量的报警信息（比如：邮件、短信）。这些人为已经预知的情况下，其实不想在收到通知！ 解决办法比如zabbix_server调用的邮件通知，把邮件脚本改成： 1echo `date` &gt;&gt; /tmp/sms.txt 这样的操作很明显能弯路思想改善接受大量报警信息。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins基本使用]]></title>
    <url>%2F2018%2F02%2F23%2Fjenkins%2F</url>
    <content type="text"><![CDATA[jenkins基本使用Install这个很简单，直接在官网下载安装即可。 jenkins前期使用思路 安装插件 如果需要git或者gitlab插件，可按上图添加。 ##服务器说明 - gitlab: 192.168.62.206 - jenkins: 192.168.62.210:8080 - deploy_server: 192.168.63.116 添加SSH_Key系统管理&gt;&gt;系统设置&gt;&gt;SSH server 选择高级key栏填写deploy_server的私钥 构建工程 选择刚构建的工程，我这里为ams运维平台 Exec command 可以使写命令，也可以使用脚本。 代码更新立即构建相当于UPdate 上述是基本的流程 持续集成&amp;安装部署jenkins从git获取代码如果项目更新的比较频繁，就可以用到CI了，持续集成&amp;安装部署jenkins从git获取代码。 一、 持续集成的概念：1.1 总体的概括 持续集成Continuous Integration 持续交付Continuous Delivery 持续部署Continuous Deployment 1.2 什么是持续集成 续集成是指开发者在代码的开发过程中，可以频繁的将代码部署集成到主干，并进程自动化测试。 1.3 什么是持续交付 持续交付指的是在持续集成的环境基础之上，将代码部署到预生产环境 1.4 持续部署 在持续交付的基础上，把部署到生产环境的过程自动化，持续部署和持续交付的区别就是最终部署到生产环境是自动化的。 #####以 新工程local_ams为例 新建工程略。。。 jenkins服务器和deploy_server要生成ssh公钥和密钥 gitlab上配置local_ams项目设置private deploy key 在jenkins服务器192.168.3.199上测试下是否能够正常获取代码 [root@linux-node2 tmp]# git clone git@192.168.62.206:OPS/AMS.git Initialized empty Git repository in /tmp/AMS/.git/ remote: Counting objects: 1587, done. remote: Compressing objects: 100% (1132/1132), done. remote: Total 1587 (delta 420), reused 1533 (delta 368) Receiving objects: 100% (1587/1587), 6.81 MiB | 11.07 MiB/s, done. Resolving deltas: 100% (420/420), done. 配置git项目地址，我们先进行其他配置，等会再继续配置git相关的选项 在填写git地址时，会报权限问题，暂忽略，一会回来配置 系统管理 –&gt; Global Tool Configuration 复制jenkins拉取git代码服务器root的私钥(jenkins服务端私钥) 继续编辑配置 配置定时任务 如果每2分钟执行建议使用 H/2 而不是 /2 * 现在我们当前如果执行的节点是 deploy_server端的deploy.php文件内容是这样 修改本地内容 提交代码 gitlab上已生成 等待2分钟后，查看结果 deploy_server端也成功更新 gitlab全局deploy Keys添加后，在需要部署项目上一定要启动该key,否则clone时会报错： [root@192v168v62v210 tmp]# git clone git@192.168.62.206:Mall/eureka.git Initialized empty Git repository in /tmp/eureka/.git/ GitLab: The project you were looking for could not be found. fatal: The remote end hung up unexpectedly]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字段和方法]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[首先，要知道Python类中两个概念：字段和方法“字段”和“方法”都有“动态”和“静态”之分，即： 字段 静态字段 动态字段 方法 静态方法 动态方法 以下事例标明了：“静态字段”，“动态字段”以及“动态方法”是什么样子的，因为显而易见，就不用语言进行过多描述： #coding:utf-8 class Car: # 下面是静态字段 memo = u'车辆具有出厂合格证' def __init__(self, brand, model, speed, price, engine): # 下面是动态字段 self.Brand = brand self.Model = model self.Speed = speed self.Price = price self.__EngineType = engine # 下面是动态方法 def Turnleft(self): print self.Brand + u'开始向右转向。' 上述事例中，并没有展现“静态方法”，那么“静态方法”长什么样子？如何生成？其实“静态方法”只需要执行两步操作，就可以转换成“静态方法” 在方法前加上 @staticmethod 把“动态方法”括号中的“self”去掉 如： @staticmethod def Forward(): print u'开始向前进' 那么关于这四种类型，有什么特点？以下进行总结： 四种类型，均可以被“对象”进行调用，但不建议使用“对象”调用“静态方法”和“静态字段”，而建议使用“类”对其进行调用 “动态方法”和“动态字段”只能由“对象”进行调用，而无法使用“类”进行调用]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix报警]]></title>
    <url>%2F2018%2F02%2F23%2Fzabbix%E6%8A%A5%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[概述当zabbix server预定义或自定义的触发器生效后，就要通过告警邮件、短信、微信等接口通知相关人员，并且zabbix server还设置了报警升级，可根据自身情况进行设置。 ##配置 一、 zabbix-server脚本指定位置1vim zabbix_server.conf AlertScriptsPath=/etc/zabbix/alertscripts 二、 报警类型（这里主要讲邮件和短信，后期会补上微信） 邮件 邮件报警需要提供三个参数（收件人、主题、内容）,邮件需要安装sendemail可见安装sendemail 1cat /etc/zabbix/alertscripts/sendEmail.sh &lt;pre&gt; #!/bin/bash to=$1 subject=$2 body=$3 /usr/local/bin/sendEmail -f ex@uu.com -t &quot;$to&quot; -u &quot;$subject&quot; -o message-content-type=html -o message-charset=utf8 -xu ex@uu.com -xp xxxx -m &quot;$body&quot; ############ /usr/local/bin/sendEmail 命令主程序 -f from@163.com 发件人邮箱 -t to@163.com 收件人邮箱 -s smtp.163.com 发件人邮箱的smtp服务器 -u &quot;我是邮件主题&quot; 邮件的标题 -o message-content-type=html 邮件内容的格式,html表示它是html格式 -o message-charset=utf8 邮件内容编码 -xu from@163.com 发件人邮箱的用户名 -xp 123456 发件人邮箱密码 -m &quot;我是邮件内容&quot; 邮件的具体内容 -l /var/log/sendMyEmail.log 非必输项，邮件发送日志记录到日志文件 &lt;/pre&gt; - web配置 1. **管理** &gt;&gt; **报警媒介类型** &gt;&gt; **创建媒体类型** 名称： 自定义 类型： 脚本 脚本参数： {ALERT.SENDTO} {ALERT.SUBJECT} {ALERT.MESSAGE} ![](https://raw.githubusercontent.com/sundshinerj/img/master/zabbix_%E6%8A%A5%E8%AD%A6_%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6_%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE.png) 2. **管理** &gt;&gt; **用户** &gt;&gt; **报警媒介** ![](https://raw.githubusercontent.com/sundshinerj/img/master/zabbix_%E6%8A%A5%E8%AD%A6_%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6_%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE.png) 3. **配置** &gt;&gt; **动作** &gt;&gt; **触发器类型下新建动作** ![](https://raw.githubusercontent.com/sundshinerj/img/master/zabbix_%E6%8A%A5%E8%AD%A6_%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6_%E5%8A%A8%E4%BD%9C%E5%90%8D%E7%A7%B0.png) &lt;pre&gt; 名称：Zabbix-Server告警邮件 默认接收人：主机： {HOSTNAME1} 状态：{TRIGGER.STATUS} 默认信息： 告警主机:&amp;nbsp;{HOSTNAME1}&lt;br/&gt; 告警时间:&amp;nbsp;{EVENT.DATE}{EVENT.TIME}&lt;br/&gt; 告警等级:&amp;nbsp;{TRIGGER.SEVERITY}&lt;br/&gt; 告警信息:&amp;nbsp;{TRIGGER.NAME}&lt;br/&gt; 告警项目:&amp;nbsp;{TRIGGER.KEY1}&lt;br/&gt; 问题详情:&amp;nbsp;{ITEM.NAME}:&amp;nbsp;{ITEM.VALUE}&lt;br/&gt; 当前状态:&amp;nbsp;{TRIGGER.STATUS}:&amp;nbsp;{ITEM.VALUE1}&lt;br/&gt; 事件ID:&amp;nbsp;{EVENT.ID}&lt;br/&gt; 恢复主题：主机： {HOSTNAME1} 状态：{TRIGGER.STATUS}！！ 恢复信息：同上 &lt;/pre&gt; - 条件 ![](https://raw.githubusercontent.com/sundshinerj/img/master/zabbix_%E6%8A%A5%E8%AD%A6_%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6_%E5%8A%A8%E4%BD%9C%E6%9D%A1%E4%BB%B6.png) - 操作 ![](https://raw.githubusercontent.com/sundshinerj/img/master/zabbix_%E6%8A%A5%E8%AD%A6_%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6_%E5%8A%A8%E4%BD%9C%E6%93%8D%E4%BD%9C.png) 步骤：可以指定报警升级 至此，邮件报警配置完成！ 短信 短信就是调用短息商提供的短信接口，参数里需要填写两个（收件人、内容） 名称： 自定义 类型： 脚本 脚本参数： {ALERT.SENDTO} {ALERT.MESSAGE} 代码 1cat sendSms.py &lt;pre&gt; #! /usr/bin/python #encoding:utf-8 import requests import json import urllib import hashlib import os import sys import subprocess import datetime reload(sys) #设置字符集，否则再输出重定向时出编码错误 sys.setdefaultencoding(&apos;utf-8&apos;) #请求主题参数 def phonelist(plist): phonelist=plist.split(&quot;,&quot;) return phonelist def requestinterface(strp): url=&quot;http://test.com?sname=接口用户名&amp;spwd=接口密码&quot; #定义一个字典，值为请求的参数 param={} param[&apos;sdst&apos;]=strp param[&apos;smsg&apos;]=sys.argv[2] str3=url+&apos;sdst=&apos;+param[&apos;sdst&apos;]+&apos;&amp;smsg=&apos;+urllib.quote(param[&apos;smsg&apos;]+&apos;【标题】&apos;) r = requests.get(str3,verify=False) if __name__ == &apos;__main__&apos;: #now=datetime.datetime.now().strftime(&apos;%Y-%m-%d-%H&apos;) #os.system(&quot;touch sendsms.`date +\&apos;%F-%H\&apos;`&quot;) #print fname #f = open(&apos;sendsms.&apos;+str(now),&apos;a&apos;) #f.write(sys.argv[1]+&apos; -- &apos;+sys.argv[2]+&apos; &apos;+str(now)+&apos;\n&apos;) plist=phonelist(sys.argv[1]) for i,value in enumerate(plist): sms=requestinterface(value) &lt;/pre&gt; 至此，短信报警配置完成。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监控网络设备]]></title>
    <url>%2F2018%2F02%2F23%2Fzabbix_monito%2F</url>
    <content type="text"><![CDATA[一、zabbix-server端安装snmp工具1yum -y install net-snmp-utils snmp-libs snmp-devel snmp 二、检测与路由器的连通性测试之前工作 路由上要开启snmp功能 本地snmp服务器的snmp的密码和路由上的密码一致 1vim /etc/snmp/snmpd.conf 测试连通性 1snmpwalk -v 2c -c 19e#! 10.18.221.4 - 2c：协议版本 - 19e#!：密码与路由一致， - 10.18.221.4：路由IP 注意selinux、iptables 如果出现上面信息说明成功 三、zabbix-server添加路由监控主机 –&gt; 创建主机 由于添加了密钥认证，须在zabbix-server中添加密钥管理–&gt;一般–&gt;选择宏，进行设置 过几分钟就能出相关监控项了！]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix_agent主动模式]]></title>
    <url>%2F2018%2F02%2F23%2Fzabbix_agent%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述当zabbix-server监控主机过多时候，由于server端去搜集信息，zabbix会出现严重的性能问题，比如: 当监控端到一个量级的时候，web操作界面很卡，容易出现502； 图层断裂； 开启的进程太多，即使item数量减少，以后加一定量的机器也会出现问题。 所以主要往2个优化方面考虑： 添加proxy节点或者node模式做分布式监控； 调整agentd为主动模式。 由于第一个方案需要物理节点，所以尝试第二个方案。 主动模式： 主动模式一定要记得设置ServerActive=ServerIP Agent向Server建立一个TCP连接 Agent请求需要检测的数据列表 Server响应Agent，发送一个Items列表 Agent允许响应 TCP连接完成本次会话关闭 Agent开始周期性地收集数据 一、 被监控端zabbix_agentd.conf的配置调整1vim /etc/zabbix/zabbix_agentd.conf StartAgents=0 #客户端的anent的模式，0表示关闭被动模式，zabbix-agentd不监控本地端口，所以看不到zabbix_agentd进程 #Server=172.16.100.84 #如果设置纯被动模式，应该注释掉这行 ServerActive=172.16.100.84 #主动模式的serverip地址 Hostname=172.16.100.47 #客户端的hostname，不配置则使用主机名 RefreshActiveChecks=120 #被监控端到服务器获取监控项的周期，默认120S BufferSize=200 #被监控端存储监控信息的空间大小 Timeout=3 #超时时间 纯主动监控模式下的zabbix agent，只能支持zabbix agent (active)类型的监控项 二、 调整监控模版 克隆一个temple os linux模版来修改 全选 找到最下方的批量更新 类型打勾，选择主动式，然后更新 主机修改 添加完成之后，你会发现zabbix的Z灯不亮，因为服务器是基于被动模式的 这时候就有相关数据，如果硬盘或网卡监控没有数据 模板&gt;&gt;主动监控模板名称&gt;&gt;自动发现规则 选择监控项原型-进去之后一个个点击，修改成主动式监控，在模版修改只，主动就会自动应用 过会，网卡和硬盘的监控情况就出来了。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell文件对比]]></title>
    <url>%2F2017%2F10%2F10%2Fshell%E6%96%87%E4%BB%B6%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[#!/bin/bash #----判断给定的文件是否存在---- if [ -d $1 ] && [ -d $2 ];then echo -e "俩个文件夹都存在,开始对俩个文件夹进行比对." else if [ -d $1 ];then echo "不存在文件夹:$2" exit else echo "不存在文件夹:$1" exit fi fi #----判断俩个文件中改动过的文件有哪些---- #判断俩个文件的文件和文件夹的个数 echo -e "\e[1;32m######查询每个文件总共有多少个文件和文件夹######\e[0m" fnum1=`ls -Rl $1|grep -e "^-"|wc -l` fnum2=`ls -Rl $2|grep -e "^-"|wc -l` dnum1=`ls -Rl $1|grep -e "^d"|wc -l` dnum2=`ls -Rl $2|grep -e "^d"|wc -l` echo -e "$1:下总共有\e[1;31m$dnum1\e[0m个文件夹,\e[1;31m$fnum1\e[0m个文件." echo -e "$2:下总共有\e[1;31m$dnum2\e[0m个文件夹,\e[1;31m$fnum2\e[0m个文件." #判断$2中新增或者减少的文件夹和文件有哪些 echo -e "\e[1;32m######查看$2中新增或者减少的文件或文件夹########\e[0m" only1=`diff -rq $1 $2|grep "^Only"|awk '{print $3,$4}'|grep -v "WEB\-INF"` only2=`diff -rq $1 $2|grep "^Only"|awk '{print $3,$4}'|grep "WEB\-INF"` echo -e "$only1" echo -e "\e[1;31m$only2\e[0m" #判断$2中改变的文件有哪些 echo -e "\e[1;32m############查看$2中改变的文件有哪些############\e[0m" change1=`diff -rq $1 $2|grep "^File"|awk '{print $2,"------",$4}'|grep -v "WEB\-INF"` change2=`diff -rq $1 $2|grep "^File"|awk '{print $2,"------",$4}'|grep "WEB\-INF"` echo -e "$change1" echo -e "\e[1;31m$change2\e[0m" #查看版本号是否已经更改 echo -e "\e[1;32m######---------查看是否更改版本号---------######\e[0m" cd $1 if [ -f version.html ];then version1=`cat version.html` else echo -e "\e[1;31m$1没有版本号信息.\e[0m" exit fi cd $2 if [ -f version.html ];then version2=`cat version.html` else echo -e "\e[1;31m$2没有版本号信息.\e[0m" exit fi if [ $version1 == $version2 ];then echo -e "\e[1;31m版本号未改动,$1和$2的版本号为$version1\e[0m" else echo -e "\e[1;31;1m版本号已经改动过\e[0m,$1的版本号为\e[1;31;1m$version1\e[0m,$2的版本号为\e[1;31;1m$version2\e[0m." fi]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>shell随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ping包检测]]></title>
    <url>%2F2017%2F10%2F10%2Fpython_ping%E5%8C%85%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[ping包检测 #!/usr/bin/env python #-*- coding: utf-8 -*- import re import subprocess def check_alive(ip,count=1,timeout=1): ''' ping网络测试,通过调用ping命令,发送一个icmp包，从结果中通过正则匹配是否有100%关键字，有则表示丢包，无则表示正常 ''' cmd = 'ping -c %d -w %d %s' % (count,timeout,ip) p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True ) result = p.stdout.read() regex = re.findall('100% packet loss',result) if len(regex) == 0: print "\033[31m%s UP\033[0m" % (ip) else: print "\033[32m%s DOWN\033[0m" % (ip) if __name__ == "__main__": with file('/root/ip.txt','r') as f: for line in f.readlines(): ip = line.strip() check_alive(ip)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录linux用户操作]]></title>
    <url>%2F2017%2F08%2F23%2Flinux%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[记录用户操作追加在 /etc/profilePS1=”whoami@hostname:”‘[$PWD]’historyUSER_IP=who -u am i 2&gt;/dev/null| awk &#39;{print $NF}&#39;|sed -e &#39;s/[()]//g&#39;if [ “$USER_IP” = “” ]thenUSER_IP=hostnamefiif [ ! -d /tmp/dbasky ]thenmkdir /tmp/dbaskychmod 777 /tmp/dbaskyfiif [ ! -d /tmp/dbasky/${LOGNAME} ]thenmkdir /tmp/dbasky/${LOGNAME}chmod 300 /tmp/dbasky/${LOGNAME}fiexport HISTSIZE=4096DT=date &quot;+%Y-%m-%d_%H:%M:%S&quot;export HISTFILE=”/tmp/dbasky/${LOGNAME}/${USER_IP} dbasky.$DT”chmod 600 /tmp/dbasky/${LOGNAME}/dbasky 2&gt;/dev/nullPS1=”whoami@hostname:”‘[$PWD]’historyUSER_IP=who -u am i 2&gt;/dev/null| awk &#39;{print $NF}&#39;|sed -e &#39;s/[()]//g&#39;if [ “$USER_IP” = “” ]thenUSER_IP=hostnamefiif [ ! -d /tmp/dbasky ]thenmkdir /tmp/dbaskychmod 777 /tmp/dbaskyfiif [ ! -d /tmp/dbasky/${LOGNAME} ]thenmkdir /tmp/dbasky/${LOGNAME}chmod 300 /tmp/dbasky/${LOGNAME}fiexport HISTSIZE=4096DT=date &quot;+%Y-%m-%d_%H:%M:%S&quot;export HISTFILE=”/tmp/dbasky/${LOGNAME}/${USER_IP} dbasky.$DT”chmod 600 /tmp/dbasky/${LOGNAME}/dbasky 2&gt;/dev/nullPS1=”whoami@hostname:”‘[$PWD]’historyUSER_IP=who -u am i 2&gt;/dev/null| awk &#39;{print $NF}&#39;|sed -e &#39;s/[()]//g&#39;if [ “$USER_IP” = “” ]thenUSER_IP=hostnamefiif [ ! -d /tmp/dbasky ]thenmkdir /tmp/dbaskychmod 777 /tmp/dbaskyfiif [ ! -d /tmp/dbasky/${LOGNAME} ]thenmkdir /tmp/dbasky/${LOGNAME}chmod 300 /tmp/dbasky/${LOGNAME}fiexport HISTSIZE=4096DT=date &quot;+%Y-%m-%d_%H:%M:%S&quot;export HISTFILE=”/tmp/dbasky/${LOGNAME}/${USER_IP} dbasky.$DT”chmod 600 /tmp/dbasky/${LOGNAME}/dbasky 2&gt;/dev/nullPS1=”whoami@hostname:”‘[$PWD]’historyUSER_IP=who -u am i 2&gt;/dev/null| awk &#39;{print $NF}&#39;|sed -e &#39;s/[()]//g&#39;if [ “$USER_IP” = “” ]thenUSER_IP=hostnamefiif [ ! -d /tmp/dbasky ]thenmkdir /tmp/dbaskychmod 777 /tmp/dbaskyfiif [ ! -d /tmp/dbasky/${LOGNAME} ]thenmkdir /tmp/dbasky/${LOGNAME}chmod 300 /tmp/dbasky/${LOGNAME}fiexport HISTSIZE=4096DT=date &quot;+%Y-%m-%d_%H:%M:%S&quot;export HISTFILE=”/tmp/dbasky/${LOGNAME}/${USER_IP} dbasky.$DT”chmod 600 /tmp/dbasky/${LOGNAME}/dbasky 2&gt;/dev/nullPS1=”whoami@hostname:”‘[$PWD]’historyUSER_IP=who -u am i 2&gt;/dev/null| awk &#39;{print $NF}&#39;|sed -e &#39;s/[()]//g&#39;if [ “$USER_IP” = “” ]thenUSER_IP=hostnamefiif [ ! -d /tmp/dbasky ]thenmkdir /tmp/dbaskychmod 777 /tmp/dbaskyfiif [ ! -d /tmp/dbasky/${LOGNAME} ]thenmkdir /tmp/dbasky/${LOGNAME}chmod 300 /tmp/dbasky/${LOGNAME}fiexport HISTSIZE=4096DT=date &quot;+%Y-%m-%d_%H:%M:%S&quot;export HISTFILE=”/tmp/dbasky/${LOGNAME}/${USER_IP} dbasky.$DT”chmod 600 /tmp/dbasky/${LOGNAME}/dbasky 2&gt;/dev/nullPS1=”whoami@hostname:”‘[$PWD]’historyUSER_IP=who -u am i 2&gt;/dev/null| awk &#39;{print $NF}&#39;|sed -e &#39;s/[()]//g&#39;if [ “$USER_IP” = “” ]thenUSER_IP=hostnamefiif [ ! -d /tmp/dbasky ]thenmkdir /tmp/dbaskychmod 777 /tmp/dbaskyfiif [ ! -d /tmp/dbasky/${LOGNAME} ]thenmkdir /tmp/dbasky/${LOGNAME}chmod 300 /tmp/dbasky/${LOGNAME}fiexport HISTSIZE=4096DT=date &quot;+%Y-%m-%d_%H:%M:%S&quot;export HISTFILE=”/tmp/dbasky/${LOGNAME}/${USER_IP} dbasky.$DT”chmod 600 /tmp/dbasky/${LOGNAME}/dbasky 2&gt;/dev/nullPS1=”whoami@hostname:”‘[$PWD]’historyUSER_IP=who -u am i 2&gt;/dev/null| awk &#39;{print $NF}&#39;|sed -e &#39;s/[()]//g&#39;if [ “$USER_IP” = “” ]thenUSER_IP=hostnamefiif [ ! -d /tmp/dbasky ]thenmkdir /tmp/dbaskychmod 777 /tmp/dbaskyfiif [ ! -d /tmp/dbasky/${LOGNAME} ]thenmkdir /tmp/dbasky/${LOGNAME}chmod 300 /tmp/dbasky/${LOGNAME}fiexport HISTSIZE=4096DT=date &quot;+%Y-%m-%d_%H:%M:%S&quot;export HISTFILE=”/tmp/dbasky/${LOGNAME}/${USER_IP} dbasky.$DT”chmod 600 /tmp/dbasky/${LOGNAME}/dbasky 2&gt;/dev/null]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http请求方法介绍]]></title>
    <url>%2F2017%2F08%2F23%2Fhttp_%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[HTTP方法（通常也被称为“动作”）告诉服务器一个页面请求要 做 什么。以下是常见 的方法 GET浏览器告诉服务器只要 得到 页面上的信息并发送这些信息。这可能是最常见的 方法。 HEAD浏览器告诉服务器想要得到信息，但是只要得到 信息头 就行了，页面内容不要。 一个应用应该像接受到一个 GET 请求一样运行，但是不传递实际的内容。在 Flask 中，你根本不必理会这个，下层的 Werkzeug 库会为你处理好。 POST浏览器告诉服务器想要向 URL 发表 一些新的信息，服务器必须确保数据被保存好 且只保存了一次。 HTML 表单实际上就是使用这个访求向服务器传送数据的。 PUT与 POST 方法类似，不同的是服务器可能触发多次储存过程而把旧的值覆盖掉。你 可能会问这样做有什么用？这样做是有原因的。假设在传输过程中连接丢失的情况 下，一个处于浏览器和服务器之间的系统可以在不中断的情况下安全地接收第二次 请求。在这种情况下，使用 POST 方法就无法做到了，因为它只被触发一次。 DELETE删除给定位置的信息。 OPTIONS为客户端提供一个查询 URL 支持哪些方法的捷径。从 Flask 0.6 开始，自动为你 实现了这个方法。有趣的是在 HTML4 和 XHTML1 中，表单只能使用 GET 和 POST 方法。但是 JavaScript 和未来的 HTML 标准中可以使用其他的方法。此外， HTTP 近来已经变得相当 流行，浏览器不再只是唯一使用 HTTP 的客户端。比如许多版本控制系统也使用 HTTP 。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用函数]]></title>
    <url>%2F2017%2F07%2F28%2Fpython_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[isinstance判断一个对象是否是一个已知的类型，类似 type()isinstance() 与 type() 区别： type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 例如 class A: pass class B: pass isinstance(A(), A) # reutrn True type(A()) == A # return True isinstance(B(), A) # return True type(B()) == A # return False Iterable判断一个对象是否可迭代 例如 >>> from collections import Iterable >>> isinstance('abc', Iterable) # str是否可迭代 True >>> isinstance([1,2,3], Iterable) # # list是否可迭代 True >>> isinstance(123, Iterable) # 整数是否可迭代 False enumerate把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身 例如 >>> for i, value in enumerate(['a', 'b', 'c']): ... print(i, value) ... (0, 'a') (1, 'b') (2, 'c')]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则]]></title>
    <url>%2F2017%2F07%2F20%2Fpython_%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[正则表达式字符 \d： 数字 \w： 字母 \t： 制表符 . ： 除回车外所有字符 次数 *： 大于等于0 +： 大于等1 {m}： 次数 {m,n}： {3,5}从3到5 re.match和re.searchre.match: 给出的字符串起始位置去匹配 re.search: 整个字符串去匹配 例子 import re result1 = re.match(&apos;\d+&apos;, &apos;a123fdsa234f4532&apos;) result2 = re.search(&apos;\d+&apos;, &apos;a123fdsa234f4532&apos;) print(result1) print(result2) 结果 None &lt;_sre.SRE_Match object; span=(1, 4), match=&apos;123&apos;&gt; 上面可看到，如果没有返回None，否则返回一个对象，如果要取到值则为print(result2.group())。 re.findall一直找到所有相关匹配项（适合一次，100次需要编译一百次）。 例子 result3 = re.findall(&apos;\d+&apos;,&apos;a123fdsa234f4532&apos;) print(result3) 结果 [&apos;123&apos;, &apos;234&apos;, &apos;4532&apos;] re.compile返回一个对象需要用findall函数获取字符串来匹配（适合多次）。 例子 com = re.compile(&apos;\d+&apos;) print(com.findall(&apos;a123fdsa234f4532&apos;)) 结果 [&apos;123&apos;, &apos;234&apos;, &apos;4532&apos;] re.group和re.groups re.group： 获取所有 re.groups：（只获取组里面（括号里）的匹配值） 例子 result3 = re.search(&apos;(\d+)fdsa(\d+)&apos;, &apos;a123fdsa234f4532&apos;) print(result3.group()) print(result3.groups()) 结果 123fdsa234 (&apos;123&apos;, &apos;234&apos;) 查找IP 例子 ip = &apos;12.32.123.432.23432fdsa+fds;fdsa192.23.32.44_fdsa#@9ds&apos; print(re.findall(&apos;(?:\d{1,3}\.){3}\d{1,3}&apos;, ip)) 结果 [&apos;12.32.123.432&apos;, &apos;192.23.32.44&apos;]]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx笔记]]></title>
    <url>%2F2016%2F05%2F11%2Fnginx%2F</url>
    <content type="text"><![CDATA[初探nginx在启动后，会以daemon的形式在后台运行，后台进程包括一个master和多个worker进程，而master主要管理worker，包含： 接收来自外界的信号； 向各worker进程发送信号； 监控worker进程的运行状态（如果worker挂掉，会自动重新创建新的worker）。 worker之间是对等关系，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx的进程模型，可以由下图来表示： 图中可以看到master为主进程，我们只需要控制master就可以了，比如： kill -HUP pid,从容地重启nginx，他们会首先创建一个新的worker，并向老的worker发送关闭的信号，这样新老交替，就能完成平滑重启了。 当所有worker都处于listen时，当一个请求过来时，所有worker都有可能处理这个请求，nginx怎么处理呢？ worker之间的信息处理前面提到，每个worker是平等的，首先，在master进程里，先建立好需要的listen的socket（listenfd）之后，然后再fork出多个worker进程，此时worker的listenfd在连接到来时是只读的。为保证只有一个进程处理该连接，所有worker进程在注册listenfd读事件前抢accept_mutex（互斥锁），在抢到accept_mutex后就注册listenfd读事件，在该读事件里调用accept接受该连接，一切完成后就读取、解析、处理请求并返回给客户端了，可以看到，一个请求只有一个worker来处理，并只在一个worker中处理。 一个woker处理一个请求，那高并发是怎么做的呢？ 高并发处理原理nginx采用异步非阻塞方式来处理请求，那异步非阻塞是什么意思呢？先看下完整的请求过程：请求到来 –&gt; 建立连接 –&gt; 接受数据 –&gt; 发送数据，具体到系统底层就是读写事件。那阻塞与非阻塞是什么意思呢？ 阻塞 事件没有准备好，那就只能等了，等事件准备好了，才可以继续。 此时，阻塞调用会进入内核等待。 非阻塞 事件没有准备好，马上返回EAGAIN，让你先去干别的，过会再来看是否OK，等准备好了再继续。 虽然不阻塞了，但你时不时地过来检查事件状态，带来的开销也是很大的。所以，才会用到异步处理，具体到系统调用就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制正好解决了我们上面的两个问题。拿epoll来说： 1. 当事件没准备好时，放到epoll里； 2. 事件准备好了，就去读写； 3. 如果返回EAGAIN时，再次放到epoll里； 4. 当所有事件都没准备好时，才在epoll里等待。 这样，就能接受持续不断的请求了–&gt;高并发。当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。 对于web服务器，事件通常有三种类型：网络事件、信号和定时器： 网络事件 通过异步非阻塞能解决问题 信号 nginx正在等待事件（epoll_wait）时，如果程序收到信号，在信号处理函数处理完后，epoll_wait会返回错误，然后程序可再次进入epoll_wait调用。 定时器 由于epoll_wait等函数在调用的时候可以设置一个超时时间，nginx借用这个超时时间来实现定时器。]]></content>
      <categories>
        <category>Service</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础]]></title>
    <url>%2F2015%2F02%2F27%2FLinux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
</search>
